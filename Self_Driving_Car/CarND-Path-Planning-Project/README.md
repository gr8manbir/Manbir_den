# **Self-Driving car path planning project** 

## Writeup on the technical challenges and approach

**Develop a path planning pipeline**
The goals / steps of this project were the following:
* Navigate successfully around a virtual highway with other traffic
* Avoid exceeding speed limit and/or jerk and acceleration goals
* Use sensor fusion data to predict lane changes

---

This is the first project of the term 3 of udacity self driving car nano-degree. It is the first path planning algorithm
implemented to safely navigate a highway with other traffic.

---
# Contents:

- Overview
- spline curve fitting
- Spline trajectory generation
- Lane prediction and crash avoidance


---
## Overview

The car should try to go as close as possible to the 50 MPH speed limit, which means passing slower traffic when possible. The car should avoid hitting other cars at all cost as well as driving inside of the marked road lanes at all times, unless going from one lane to another. The car should be able to make one complete loop around the 6946m highway. Also the car should not experience total acceleration over 10 m/s^2 and jerk that is greater than 10 m/s^3.

The map of the highway is in data/highway_map.txt
Each waypoint in the list contains [x,y,s,dx,dy] values. x and y are the waypoint's map coordinate position, the s value is the distance along the road to get to that waypoint in meters, the dx and dy values define the unit normal vector pointing outward of the highway loop.

The highway's waypoints loop around so the frenet s value, distance along the road, goes from 0 to 6945.554.

### Basic Build Instructions
Clone this repo.
Make a build directory: mkdir build && cd build
Compile: cmake .. && make
Run it: ./path_planning.

### Data provided
Here is the data provided from the Simulator to the C++ Program:

Main car's localization Data (No Noise)
["x"] The car's x position in map coordinates

["y"] The car's y position in map coordinates

["s"] The car's s position in frenet coordinates

["d"] The car's d position in frenet coordinates

["yaw"] The car's yaw angle in the map

["speed"] The car's speed in MPH

Sensor Fusion Data, a list of all other car's attributes on the same side of the road. (No Noise)
["sensor_fusion"] A 2d vector of cars and then that car's [car's unique ID, car's x position in map coordinates, car's y position in map coordinates, car's x velocity in m/s, car's y velocity in m/s, car's s position in frenet coordinates, car's d position in frenet coordinates.

---
## Prediction

Prediction of a trajectory depends on the following steps:

1. Lane prediction from frenet co-ordinate space using sensor fusion data

2. Generation of 5 (x,y) co-ordinate points that are used to fit a spline from the car's localization data

3. Generation of atleast about 50 waypoints from the spline 
 
Each of these is described in sections below.

---
## Generation of waypoints for spline curve fitting

This step consists of generating 5 pair of (x,y) points that can be used to fit a spline curve. The first two points are taken from the previous way points.

There are two separate situations to be considered:

1. No previous set of (x,y) points exist. In this case, the current car's (x,y) is chosen of the points. The previous (x,y) are generated via backtracking. This can be seen as follows:

	if(prev_size < 2)
	{
		//Use two points that make the path tangent to the car
		double prev_car_x = car_x - cos(car_yaw);
		double prev_car_y = car_y - sin(car_yaw);
				
		ptsx.push_back(prev_car_x);
		ptsx.push_back(car_x);
				
		ptsy.push_back(prev_car_y);
		ptsy.push_back(car_y);
	}

2. If previous set of (x,y) points exist, the last two points are taken as way points. The remaining 3 waypoints for fitting the spline are generated by projecting the current position outwards at 30, 60 and 90 meters. This can be seen in following code:

	vector<double> next_wp0 = getXY(car_s+30,(2+4*lane), map_waypoints_s, map_waypoints_x, map_waypoints_y);
	vector<double> next_wp1 = getXY(car_s+60,(2+4*lane), map_waypoints_s, map_waypoints_x, map_waypoints_y);
	vector<double> next_wp2 = getXY(car_s+90,(2+4*lane), map_waypoints_s, map_waypoints_x, map_waypoints_y);
			
	ptsx.push_back(next_wp0[0]);
	ptsx.push_back(next_wp1[0]);
	ptsx.push_back(next_wp2[0]);
			
	ptsy.push_back(next_wp0[1]);
	ptsy.push_back(next_wp1[1]);
	ptsy.push_back(next_wp2[1]);

These five points are fit into a spline wave to generate a spline curve as follows:

	tk::spline s;
			
	// Fit the spline on (x,y)
	s.set_points(ptsx,ptsy);

---

## Generation of 50 waypoints from spline

This step involves generation of 50 (x,y) points over a distance over 30 meters. This has to also account for speed. This consists of the following:

1. Use the previous path waypoints as the first set of waypoints.
2. Set x as 30 
3. Generate y from the spline
4. Calculate the target distance by sqrt(x2 +y2)
5. Generate the remaining waypoints

This can be seen as follows:

	// Start with all the previous path points from last time
	for (int i = 0; i < previous_path_x.size(); i++) {
		next_x_vals.push_back(previous_path_x[i]);
		next_y_vals.push_back(previous_path_y[i]);
	}

	// Compute how to break up spline points so we travel at our desired reference velocity
	double target_x = 30.0;
	double target_y = s(target_x);
	double target_dist = sqrt((target_x) * (target_x) + (target_y) * (target_y));
	double x_add_on = 0;

	// Fill up the rest of the path planner to always output 50 points
	for (int i = 1; i <= 50 - previous_path_x.size(); i++) {
		double N = (target_dist/(.02*ref_vel/2.24));
		double x_point = x_add_on + (target_x) / N;
		double y_point = s(x_point);

		x_add_on = x_point;

		double x_ref = x_point;
		double y_ref = y_point;

		// Rotate back to normal after rotating it earlier
		x_point = (x_ref * cos(ref_yaw) - y_ref*sin(ref_yaw));
		y_point = (x_ref * sin(ref_yaw) + y_ref*cos(ref_yaw));

		x_point += ref_x;
		y_point += ref_y;

		next_x_vals.push_back(x_point);
		next_y_vals.push_back(y_point);
	}

These 50 points form the trajectory of the car.

---
## Lane prediction and crash avoidance

This depends on sensor fusion data. This involves the following steps:

1. Predicting if there is a car ahead of us. If so, we need to do the following:
	a. Predicting the lane of the car in sensor fusion data.

	The above steps can be seen in below code:

			
	//find other car lane
	float d = sensor_fusion[i][6];
	int check_car_lane  = 0;
				
	if( d >=0 && d < 4)
	{
		/* Between 0 m and 4 m is lane 0 */
		check_car_lane = 0;
	}
	else if ( d>=4 && d < 8 )
	{
		/* Between 4 and 8 m, lane 1 */
		check_car_lane = 1;
	}
	else if ( d >= 8 && d <=12 )
	{
		/* Between 8 and 12m is lane 2*/
		check_car_lane = 2;
	}

	b. Check if there is a car in the left lane( front/back of us ). 
	c. Check if there is a car in the right lane( front/back of us ).

	//Compare our car against others
	double check_car_s = sensor_fusion[i][5];

	/* Project check_car in future time */
	check_car_s+=((double)prev_size*.02*check_speed);//predict s over time
	/* If check car is in same lane as us */
	if( 0 == check_car_lane-lane)
	{
		//check_s values greater than mine and s_gap < 30m
		if((check_car_s > car_s) && ((check_car_s-car_s) < 30) )
		{
			too_close = true;
		}
	}
	else if ( 1 ==  check_car_lane - lane )
	{
		/* check if any car is to right of us that will prevent lane change */
		if ( car_s > check_car_s )
		{
			if( (car_s - 30) <= check_car_s)
			{
				/* A car is within 30m back right of us */
				too_close_right = true;
			}
						
		}
		else
		{
			if( (check_car_s - 30) <= car_s  )
			{
				/* A car is within 30m front right of us */
				too_close_right = true;
			}
		}
	}
	else if ( 1 == lane - check_car_lane )
	{
		/* Check if car is to left of us that will prevent lane change */
		if ( car_s > check_car_s )
		{
			if( (car_s - 30) <= check_car_s)
			{
				/* A car is within 30m back left of us */
				too_close_left = true;
			}
						
		}
		else
		{
			if( (check_car_s - 30) <= car_s  )
			{
				/* A car is within 30m front left of us */
				too_close_left = true;
			}
		}
	}


2. If there is nothing in either left/right lane, we can do a lane switch.

	if ( false == too_close_right && lane < 2 )
	{
		lane++;
	}
	else if( false == too_close_left && lane > 0)
	{
		//Check if we can move left
		lane--;
	}

3. If there are cars in both of the lanes, we need to slow down.

	ref_vel -= .224; //5m/s2

4. We also have to stay in center lane, since it improves performance.
	if( 1 != lane )
	{
		if( ( (false == too_close_left) && lane == 2 ) ||
		    ( (false == too_close_right) && lane == 0 ) )
		{
			lane = 1;
		}
	}

5. Lastly, if nothing is blocking us, we need to speed up.
	if(ref_vel < 49.5)
	{
		ref_vel += .224;
	}


The project successfully moves around the track for more than one circle of 6496m.  One potential shortcoming is if a car suddenly makes a sharp cut into our lane. In such corner cases, the model may need fine tuning. 
